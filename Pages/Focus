
import React, { useState, useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Volume2, VolumeX, Play, Pause } from "lucide-react";

const BreathingCycle = ({ duration, text }) => {
    return (
        <div className="text-center transition-opacity duration-500">
            <p className="text-xl mb-4 text-white">{text}</p>
            <div className="w-16 h-16 rounded-full border-2 border-white mx-auto flex items-center justify-center animate-pulse" style={{ animationDuration: `${duration}s` }}>
                <div className="w-8 h-8 bg-white rounded-full animate-ping" style={{ animationDuration: `${duration}s` }}></div>
            </div>
        </div>
    );
};

export default function Focus() {
    const [focusMode, setFocusMode] = useState(false);
    const [ambientSoundId, setAmbientSoundId] = useState("none");
    const [soundPlaying, setSoundPlaying] = useState(false);
    const [volume, setVolume] = useState(0.3);
    const audioRef = useRef(null);

    const ambientSounds = [
        { id: "none", name: "None", description: "Pure silence" },
        { id: "white", name: "White Noise", description: "Static sound", programmatic: true }
    ];

    // Breathing exercise state
    const [breathingActive, setBreathingActive] = useState(false);
    const [breathingPhase, setBreathingPhase] = useState(0);
    const breathingPhases = [
        { text: "Inhale", duration: 4 },
        { text: "Hold", duration: 4 },
        { text: "Exhale", duration: 4 },
        { text: "Hold", duration: 4 },
    ];

    useEffect(() => {
        let timer;
        if (breathingActive) {
            const phaseDuration = breathingPhases[breathingPhase].duration * 1000;
            timer = setTimeout(() => {
                setBreathingPhase((prev) => (prev + 1) % breathingPhases.length);
            }, phaseDuration);
        }
        return () => clearTimeout(timer);
    }, [breathingActive, breathingPhase, breathingPhases]);

    const toggleFocusMode = () => {
        setFocusMode(prev => {
            const isEntering = !prev;
            if (isEntering) {
                document.documentElement.requestFullscreen().catch(e => {
                    console.error("Failed to enter fullscreen:", e);
                });
            } else {
                if (document.fullscreenElement) {
                    document.exitFullscreen().catch(e => {
                        console.error("Failed to exit fullscreen:", e);
                    });
                }
            }
            return isEntering;
        });
    };
    
    useEffect(() => {
        const handleFullscreenChange = () => {
            if (!document.fullscreenElement) {
                setFocusMode(false);
            }
        };
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
    }, []);

    // Generate white noise programmatically
    const generateWhiteNoise = () => {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const bufferSize = 2 * audioContext.sampleRate;
        const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
            output[i] = Math.random() * 2 - 1;
        }
        
        const whiteNoise = audioContext.createBufferSource();
        whiteNoise.buffer = noiseBuffer;
        whiteNoise.loop = true;
        
        const gainNode = audioContext.createGain();
        gainNode.gain.value = volume * 0.1;
        
        whiteNoise.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        return { source: whiteNoise, context: audioContext, gain: gainNode };
    };

    const [whiteNoiseNodes, setWhiteNoiseNodes] = useState(null);

    useEffect(() => {
        if (audioRef.current) {
            audioRef.current.volume = volume;
        }
        if (whiteNoiseNodes) {
            whiteNoiseNodes.gain.gain.value = volume * 0.1;
        }
    }, [volume, whiteNoiseNodes]);
    
    useEffect(() => {
        const selectedSound = ambientSounds.find(s => s.id === ambientSoundId);

        if (soundPlaying) {
            if (selectedSound?.programmatic) {
                if (!whiteNoiseNodes) {
                    const nodes = generateWhiteNoise();
                    nodes.source.start(0);
                    setWhiteNoiseNodes(nodes);
                }
            } else if (selectedSound?.url) {
                if (audioRef.current) {
                    audioRef.current.play().catch(e => console.error("Audio play failed:", e.message));
                }
            }
        } else {
            if (whiteNoiseNodes) {
                whiteNoiseNodes.source.stop();
                whiteNoiseNodes.context.close();
                setWhiteNoiseNodes(null);
            }
            if (audioRef.current) {
                audioRef.current.pause();
            }
        }

        return () => {
            if (!soundPlaying && whiteNoiseNodes) {
                whiteNoiseNodes.source.stop();
                whiteNoiseNodes.context.close();
                setWhiteNoiseNodes(null);
            }
        };
    }, [soundPlaying, ambientSoundId, ambientSounds, whiteNoiseNodes]); // Added whiteNoiseNodes to dependency array to prevent stale closure for cleanup in effect

    const handleSoundChange = (sound) => {
        setSoundPlaying(false);

        if (whiteNoiseNodes) {
            whiteNoiseNodes.source.stop();
            whiteNoiseNodes.context.close();
            setWhiteNoiseNodes(null);
        }

        if (audioRef.current) {
            audioRef.current.pause();
            audioRef.current.src = "";
            audioRef.current.load();
        }
        
        setAmbientSoundId(sound.id);
        if (sound.url && audioRef.current) {
            audioRef.current.src = sound.url;
            audioRef.current.load();
        }
    };

    const toggleAmbientSound = () => {
        if (ambientSoundId !== "none") {
            setSoundPlaying(!soundPlaying);
        }
    };
    
    return (
        <div className={`max-w-4xl mx-auto transition-all duration-300 ${focusMode ? 'fixed inset-0 bg-black p-8 z-50 overflow-y-auto' : ''}`}>
             <audio ref={audioRef} loop />
            <div className="mb-8 flex justify-between items-start">
                <div>
                    <h1 className="text-3xl font-bold mb-2 tracking-wider text-white">FOCUS</h1>
                    <p className="text-zinc-400 text-sm">Deep work environment</p>
                </div>
                {focusMode && <Button onClick={toggleFocusMode} variant="outline" className="border-zinc-700 text-white hover:bg-zinc-800">Exit Fullscreen</Button>}
            </div>

            <div className="space-y-6">
                {/* Focus Mode */}
                <div className="bg-zinc-900 rounded-2xl p-8 border border-zinc-800">
                    <div className="flex items-center justify-between mb-6">
                        <div>
                            <h2 className="text-xl font-bold tracking-wide text-white">FULLSCREEN FOCUS</h2>
                            <p className="text-zinc-400 text-sm">Enter an immersive, distraction-free mode</p>
                        </div>
                        <Button
                            onClick={toggleFocusMode}
                            className="bg-white text-black hover:bg-zinc-200"
                        >
                            {focusMode ? "Exit Focus" : "Enter Focus"}
                        </Button>
                    </div>
                    
                    <div className="text-sm text-zinc-400">
                        {focusMode 
                            ? "Focus mode is active. Press 'Esc' or the exit button to return." 
                            : "Enter fullscreen focus mode to remove all distractions from your screen."
                        }
                    </div>
                </div>

                {/* Breathing Exercise */}
                <div className="bg-zinc-900 rounded-2xl p-8 border border-zinc-800">
                     <div className="flex items-center justify-between mb-6">
                        <div>
                            <h2 className="text-xl font-bold tracking-wide text-white">BREATHING EXERCISE</h2>
                            <p className="text-zinc-400 text-sm">Calm your mind with box breathing</p>
                        </div>
                        <Button
                            onClick={() => {
                                setBreathingActive(!breathingActive);
                                if (!breathingActive) {
                                    setBreathingPhase(0);
                                }
                            }}
                             className="bg-white text-black hover:bg-zinc-200"
